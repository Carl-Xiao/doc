## 缓存穿透
> 大量的无效的key,缓存无法兜底处理,大量的请求会直接落到DB
解决方案: 布隆过滤器拦截掉无效的key

## 缓存雪崩
> key在同一个时间点,全部失效. 压力全部给到DB
解决方案: ttl设置过期时间为随机值
## 缓存击穿
> 热点key的过期, 请求的压力直接给到DB
解决方案: 
- golang中有一个singleflight的策略,核心思想是利用锁+本地缓存解决热点key的问题。
- 后台异步刷新机制, 利用定时器或者人工重置的方式

常见的几种分布式缓存大概都会遇到这么几种,灵活选择适合自己解决方案。