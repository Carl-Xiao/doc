## Redis对象

### 基本类型

> 这一点可能并不以为是你以为的那样,基本数据类型不是string,hash,set,而是基于其上再包装的一层结构

RedisObject

```c
typedef struct redisObject {

    // 类型
    unsigned type:4;

    // 编码
    unsigned encoding:4;

    // 对象最后一次被访问的时间
    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */

    // 引用计数
    int refcount;

    // 指向实际值的指针
    void *ptr;
} robj;

```

- type: 标识基本类型, redis__string redis_hash,redis_list等
  
- encoding：编码格式

  | 基本类型 | value | 编码格式 |
  | --- | --- | --- |
  | string |  字符串大于32位   | raw ==>SDS |
  | string |  数字类型   | int |
  | string |  字符串小于32位   |  embstr    |
- lru: 最近一次的访问时间,可以用在内存淘汰中,lru的淘汰算法也是借由此完成
- refcount: 引用计数(内存回收的一种实现机制) 参考java的实现
- *ptr: 实际存储对象  

> 了解这个结构可以很快的明白一些redis的逻辑策略,例如内存淘汰的lru。深入一点再看看一些有趣的结构

### SDS
> 动态字符串, 所谓的动态也就是在增加或删除的时候,能充分的利用空间.而不是一次性的申请一大块内存,又不加以使用
- 基本数据结构
```
struct sdshdr {
    int len;
    int free;
    char buf[];
}
```
> 顺便一提netty中的ByteBuf也是异曲同工的设计,将内存充分利用
- 扩大以及缩小
每次申请内存的时候会预先分配10多KB的空间,free记录还剩余的长度.
增加数据的时候,先计算字符串的长度,如果不够就再进行申请
缩小数据的时候,同理。
> 能解决问题吗？ 当然能,否则增加或减少的时候还得动态分配多次内存,如果用sds的设计,可以少分配n次。




  